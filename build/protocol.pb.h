// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2eproto;
namespace msg {
class AddExpReq;
struct AddExpReqDefaultTypeInternal;
extern AddExpReqDefaultTypeInternal _AddExpReq_default_instance_;
class AddExpRsp;
struct AddExpRspDefaultTypeInternal;
extern AddExpRspDefaultTypeInternal _AddExpRsp_default_instance_;
class BattleAction;
struct BattleActionDefaultTypeInternal;
extern BattleActionDefaultTypeInternal _BattleAction_default_instance_;
class BattleEnd;
struct BattleEndDefaultTypeInternal;
extern BattleEndDefaultTypeInternal _BattleEnd_default_instance_;
class BattleStart;
struct BattleStartDefaultTypeInternal;
extern BattleStartDefaultTypeInternal _BattleStart_default_instance_;
class BattleState;
struct BattleStateDefaultTypeInternal;
extern BattleStateDefaultTypeInternal _BattleState_default_instance_;
class BattleSync;
struct BattleSyncDefaultTypeInternal;
extern BattleSyncDefaultTypeInternal _BattleSync_default_instance_;
class ChatMsg;
struct ChatMsgDefaultTypeInternal;
extern ChatMsgDefaultTypeInternal _ChatMsg_default_instance_;
class EnterRoomAck;
struct EnterRoomAckDefaultTypeInternal;
extern EnterRoomAckDefaultTypeInternal _EnterRoomAck_default_instance_;
class EnterRoomReq;
struct EnterRoomReqDefaultTypeInternal;
extern EnterRoomReqDefaultTypeInternal _EnterRoomReq_default_instance_;
class LoginReq;
struct LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginResp;
struct LoginRespDefaultTypeInternal;
extern LoginRespDefaultTypeInternal _LoginResp_default_instance_;
class PlayerAttr;
struct PlayerAttrDefaultTypeInternal;
extern PlayerAttrDefaultTypeInternal _PlayerAttr_default_instance_;
class PositionUpdateReq;
struct PositionUpdateReqDefaultTypeInternal;
extern PositionUpdateReqDefaultTypeInternal _PositionUpdateReq_default_instance_;
class ReadyAck;
struct ReadyAckDefaultTypeInternal;
extern ReadyAckDefaultTypeInternal _ReadyAck_default_instance_;
class ReadyReq;
struct ReadyReqDefaultTypeInternal;
extern ReadyReqDefaultTypeInternal _ReadyReq_default_instance_;
class RegisterReq;
struct RegisterReqDefaultTypeInternal;
extern RegisterReqDefaultTypeInternal _RegisterReq_default_instance_;
class RegisterResp;
struct RegisterRespDefaultTypeInternal;
extern RegisterRespDefaultTypeInternal _RegisterResp_default_instance_;
class SChatMsg;
struct SChatMsgDefaultTypeInternal;
extern SChatMsgDefaultTypeInternal _SChatMsg_default_instance_;
class ViewPlayerDataReq;
struct ViewPlayerDataReqDefaultTypeInternal;
extern ViewPlayerDataReqDefaultTypeInternal _ViewPlayerDataReq_default_instance_;
}  // namespace msg
PROTOBUF_NAMESPACE_OPEN
template<> ::msg::AddExpReq* Arena::CreateMaybeMessage<::msg::AddExpReq>(Arena*);
template<> ::msg::AddExpRsp* Arena::CreateMaybeMessage<::msg::AddExpRsp>(Arena*);
template<> ::msg::BattleAction* Arena::CreateMaybeMessage<::msg::BattleAction>(Arena*);
template<> ::msg::BattleEnd* Arena::CreateMaybeMessage<::msg::BattleEnd>(Arena*);
template<> ::msg::BattleStart* Arena::CreateMaybeMessage<::msg::BattleStart>(Arena*);
template<> ::msg::BattleState* Arena::CreateMaybeMessage<::msg::BattleState>(Arena*);
template<> ::msg::BattleSync* Arena::CreateMaybeMessage<::msg::BattleSync>(Arena*);
template<> ::msg::ChatMsg* Arena::CreateMaybeMessage<::msg::ChatMsg>(Arena*);
template<> ::msg::EnterRoomAck* Arena::CreateMaybeMessage<::msg::EnterRoomAck>(Arena*);
template<> ::msg::EnterRoomReq* Arena::CreateMaybeMessage<::msg::EnterRoomReq>(Arena*);
template<> ::msg::LoginReq* Arena::CreateMaybeMessage<::msg::LoginReq>(Arena*);
template<> ::msg::LoginResp* Arena::CreateMaybeMessage<::msg::LoginResp>(Arena*);
template<> ::msg::PlayerAttr* Arena::CreateMaybeMessage<::msg::PlayerAttr>(Arena*);
template<> ::msg::PositionUpdateReq* Arena::CreateMaybeMessage<::msg::PositionUpdateReq>(Arena*);
template<> ::msg::ReadyAck* Arena::CreateMaybeMessage<::msg::ReadyAck>(Arena*);
template<> ::msg::ReadyReq* Arena::CreateMaybeMessage<::msg::ReadyReq>(Arena*);
template<> ::msg::RegisterReq* Arena::CreateMaybeMessage<::msg::RegisterReq>(Arena*);
template<> ::msg::RegisterResp* Arena::CreateMaybeMessage<::msg::RegisterResp>(Arena*);
template<> ::msg::SChatMsg* Arena::CreateMaybeMessage<::msg::SChatMsg>(Arena*);
template<> ::msg::ViewPlayerDataReq* Arena::CreateMaybeMessage<::msg::ViewPlayerDataReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace msg {

enum ChatChannel : int {
  WORLD = 0,
  PRIVATE = 1,
  ChatChannel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChatChannel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChatChannel_IsValid(int value);
constexpr ChatChannel ChatChannel_MIN = WORLD;
constexpr ChatChannel ChatChannel_MAX = PRIVATE;
constexpr int ChatChannel_ARRAYSIZE = ChatChannel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChatChannel_descriptor();
template<typename T>
inline const std::string& ChatChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChatChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChatChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChatChannel_descriptor(), enum_t_value);
}
inline bool ChatChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChatChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChatChannel>(
    ChatChannel_descriptor(), name, value);
}
// ===================================================================

class ChatMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ChatMsg) */ {
 public:
  inline ChatMsg() : ChatMsg(nullptr) {}
  ~ChatMsg() override;
  explicit constexpr ChatMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatMsg(const ChatMsg& from);
  ChatMsg(ChatMsg&& from) noexcept
    : ChatMsg() {
    *this = ::std::move(from);
  }

  inline ChatMsg& operator=(const ChatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatMsg& operator=(ChatMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatMsg* internal_default_instance() {
    return reinterpret_cast<const ChatMsg*>(
               &_ChatMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChatMsg& a, ChatMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChatMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ChatMsg";
  }
  protected:
  explicit ChatMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kChannelFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .msg.ChatChannel channel = 1;
  void clear_channel();
  ::msg::ChatChannel channel() const;
  void set_channel(::msg::ChatChannel value);
  private:
  ::msg::ChatChannel _internal_channel() const;
  void _internal_set_channel(::msg::ChatChannel value);
  public:

  // int32 to = 2;
  void clear_to();
  int32_t to() const;
  void set_to(int32_t value);
  private:
  int32_t _internal_to() const;
  void _internal_set_to(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ChatMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int channel_;
  int32_t to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class SChatMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.SChatMsg) */ {
 public:
  inline SChatMsg() : SChatMsg(nullptr) {}
  ~SChatMsg() override;
  explicit constexpr SChatMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SChatMsg(const SChatMsg& from);
  SChatMsg(SChatMsg&& from) noexcept
    : SChatMsg() {
    *this = ::std::move(from);
  }

  inline SChatMsg& operator=(const SChatMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SChatMsg& operator=(SChatMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SChatMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SChatMsg* internal_default_instance() {
    return reinterpret_cast<const SChatMsg*>(
               &_SChatMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SChatMsg& a, SChatMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SChatMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SChatMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SChatMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SChatMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SChatMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SChatMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SChatMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.SChatMsg";
  }
  protected:
  explicit SChatMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kChannelFieldNumber = 1,
    kFromFieldNumber = 2,
  };
  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .msg.ChatChannel channel = 1;
  void clear_channel();
  ::msg::ChatChannel channel() const;
  void set_channel(::msg::ChatChannel value);
  private:
  ::msg::ChatChannel _internal_channel() const;
  void _internal_set_channel(::msg::ChatChannel value);
  public:

  // int32 from = 2;
  void clear_from();
  int32_t from() const;
  void set_from(int32_t value);
  private:
  int32_t _internal_from() const;
  void _internal_set_from(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.SChatMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int channel_;
  int32_t from_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class ViewPlayerDataReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ViewPlayerDataReq) */ {
 public:
  inline ViewPlayerDataReq() : ViewPlayerDataReq(nullptr) {}
  ~ViewPlayerDataReq() override;
  explicit constexpr ViewPlayerDataReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ViewPlayerDataReq(const ViewPlayerDataReq& from);
  ViewPlayerDataReq(ViewPlayerDataReq&& from) noexcept
    : ViewPlayerDataReq() {
    *this = ::std::move(from);
  }

  inline ViewPlayerDataReq& operator=(const ViewPlayerDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ViewPlayerDataReq& operator=(ViewPlayerDataReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ViewPlayerDataReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ViewPlayerDataReq* internal_default_instance() {
    return reinterpret_cast<const ViewPlayerDataReq*>(
               &_ViewPlayerDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ViewPlayerDataReq& a, ViewPlayerDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ViewPlayerDataReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ViewPlayerDataReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ViewPlayerDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ViewPlayerDataReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ViewPlayerDataReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ViewPlayerDataReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ViewPlayerDataReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ViewPlayerDataReq";
  }
  protected:
  explicit ViewPlayerDataReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ViewPlayerDataReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerAttr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.PlayerAttr) */ {
 public:
  inline PlayerAttr() : PlayerAttr(nullptr) {}
  ~PlayerAttr() override;
  explicit constexpr PlayerAttr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerAttr(const PlayerAttr& from);
  PlayerAttr(PlayerAttr&& from) noexcept
    : PlayerAttr() {
    *this = ::std::move(from);
  }

  inline PlayerAttr& operator=(const PlayerAttr& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAttr& operator=(PlayerAttr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerAttr& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerAttr* internal_default_instance() {
    return reinterpret_cast<const PlayerAttr*>(
               &_PlayerAttr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PlayerAttr& a, PlayerAttr& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerAttr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerAttr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerAttr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerAttr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerAttr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerAttr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerAttr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PlayerAttr";
  }
  protected:
  explicit PlayerAttr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kLevelFieldNumber = 3,
    kExpFieldNumber = 4,
    kHpFieldNumber = 5,
    kMpFieldNumber = 6,
    kCoinFieldNumber = 7,
    kXFieldNumber = 8,
    kYFieldNumber = 9,
    kZFieldNumber = 10,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 level = 3;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // int32 exp = 4;
  void clear_exp();
  int32_t exp() const;
  void set_exp(int32_t value);
  private:
  int32_t _internal_exp() const;
  void _internal_set_exp(int32_t value);
  public:

  // int32 hp = 5;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // int32 mp = 6;
  void clear_mp();
  int32_t mp() const;
  void set_mp(int32_t value);
  private:
  int32_t _internal_mp() const;
  void _internal_set_mp(int32_t value);
  public:

  // int32 coin = 7;
  void clear_coin();
  int32_t coin() const;
  void set_coin(int32_t value);
  private:
  int32_t _internal_coin() const;
  void _internal_set_coin(int32_t value);
  public:

  // float x = 8;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 9;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 10;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PlayerAttr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  int32_t level_;
  int32_t exp_;
  int32_t hp_;
  int32_t mp_;
  int32_t coin_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class RegisterReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.RegisterReq) */ {
 public:
  inline RegisterReq() : RegisterReq(nullptr) {}
  ~RegisterReq() override;
  explicit constexpr RegisterReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterReq(const RegisterReq& from);
  RegisterReq(RegisterReq&& from) noexcept
    : RegisterReq() {
    *this = ::std::move(from);
  }

  inline RegisterReq& operator=(const RegisterReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterReq& operator=(RegisterReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterReq* internal_default_instance() {
    return reinterpret_cast<const RegisterReq*>(
               &_RegisterReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegisterReq& a, RegisterReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.RegisterReq";
  }
  protected:
  explicit RegisterReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswdFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // @@protoc_insertion_point(class_scope:msg.RegisterReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class RegisterResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.RegisterResp) */ {
 public:
  inline RegisterResp() : RegisterResp(nullptr) {}
  ~RegisterResp() override;
  explicit constexpr RegisterResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResp(const RegisterResp& from);
  RegisterResp(RegisterResp&& from) noexcept
    : RegisterResp() {
    *this = ::std::move(from);
  }

  inline RegisterResp& operator=(const RegisterResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResp& operator=(RegisterResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResp* internal_default_instance() {
    return reinterpret_cast<const RegisterResp*>(
               &_RegisterResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RegisterResp& a, RegisterResp& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.RegisterResp";
  }
  protected:
  explicit RegisterResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kOkFieldNumber = 1,
    kUidFieldNumber = 3,
  };
  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // int32 uid = 3;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.RegisterResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  bool ok_;
  int32_t uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  ~LoginReq() override;
  explicit constexpr LoginReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswdFieldNumber = 2,
    kUidFieldNumber = 1,
  };
  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
  int32_t uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.LoginResp) */ {
 public:
  inline LoginResp() : LoginResp(nullptr) {}
  ~LoginResp() override;
  explicit constexpr LoginResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResp(const LoginResp& from);
  LoginResp(LoginResp&& from) noexcept
    : LoginResp() {
    *this = ::std::move(from);
  }

  inline LoginResp& operator=(const LoginResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResp& operator=(LoginResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResp* internal_default_instance() {
    return reinterpret_cast<const LoginResp*>(
               &_LoginResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoginResp& a, LoginResp& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LoginResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.LoginResp";
  }
  protected:
  explicit LoginResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // string reason = 2;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.LoginResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class PositionUpdateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.PositionUpdateReq) */ {
 public:
  inline PositionUpdateReq() : PositionUpdateReq(nullptr) {}
  ~PositionUpdateReq() override;
  explicit constexpr PositionUpdateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PositionUpdateReq(const PositionUpdateReq& from);
  PositionUpdateReq(PositionUpdateReq&& from) noexcept
    : PositionUpdateReq() {
    *this = ::std::move(from);
  }

  inline PositionUpdateReq& operator=(const PositionUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PositionUpdateReq& operator=(PositionUpdateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PositionUpdateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PositionUpdateReq* internal_default_instance() {
    return reinterpret_cast<const PositionUpdateReq*>(
               &_PositionUpdateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PositionUpdateReq& a, PositionUpdateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PositionUpdateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PositionUpdateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PositionUpdateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PositionUpdateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PositionUpdateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PositionUpdateReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionUpdateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PositionUpdateReq";
  }
  protected:
  explicit PositionUpdateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PositionUpdateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class AddExpReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.AddExpReq) */ {
 public:
  inline AddExpReq() : AddExpReq(nullptr) {}
  ~AddExpReq() override;
  explicit constexpr AddExpReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddExpReq(const AddExpReq& from);
  AddExpReq(AddExpReq&& from) noexcept
    : AddExpReq() {
    *this = ::std::move(from);
  }

  inline AddExpReq& operator=(const AddExpReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddExpReq& operator=(AddExpReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddExpReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddExpReq* internal_default_instance() {
    return reinterpret_cast<const AddExpReq*>(
               &_AddExpReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AddExpReq& a, AddExpReq& b) {
    a.Swap(&b);
  }
  inline void Swap(AddExpReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddExpReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddExpReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddExpReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddExpReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddExpReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddExpReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.AddExpReq";
  }
  protected:
  explicit AddExpReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kExpAddFieldNumber = 2,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 exp_add = 2;
  void clear_exp_add();
  int32_t exp_add() const;
  void set_exp_add(int32_t value);
  private:
  int32_t _internal_exp_add() const;
  void _internal_set_exp_add(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.AddExpReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  int32_t exp_add_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class AddExpRsp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.AddExpRsp) */ {
 public:
  inline AddExpRsp() : AddExpRsp(nullptr) {}
  ~AddExpRsp() override;
  explicit constexpr AddExpRsp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddExpRsp(const AddExpRsp& from);
  AddExpRsp(AddExpRsp&& from) noexcept
    : AddExpRsp() {
    *this = ::std::move(from);
  }

  inline AddExpRsp& operator=(const AddExpRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddExpRsp& operator=(AddExpRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddExpRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddExpRsp* internal_default_instance() {
    return reinterpret_cast<const AddExpRsp*>(
               &_AddExpRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AddExpRsp& a, AddExpRsp& b) {
    a.Swap(&b);
  }
  inline void Swap(AddExpRsp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddExpRsp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddExpRsp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddExpRsp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddExpRsp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddExpRsp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddExpRsp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.AddExpRsp";
  }
  protected:
  explicit AddExpRsp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kNewLevelFieldNumber = 2,
    kNewExpFieldNumber = 3,
    kLevelUpFieldNumber = 4,
    kSuccessFieldNumber = 5,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 new_level = 2;
  void clear_new_level();
  int32_t new_level() const;
  void set_new_level(int32_t value);
  private:
  int32_t _internal_new_level() const;
  void _internal_set_new_level(int32_t value);
  public:

  // int32 new_exp = 3;
  void clear_new_exp();
  int32_t new_exp() const;
  void set_new_exp(int32_t value);
  private:
  int32_t _internal_new_exp() const;
  void _internal_set_new_exp(int32_t value);
  public:

  // bool level_up = 4;
  void clear_level_up();
  bool level_up() const;
  void set_level_up(bool value);
  private:
  bool _internal_level_up() const;
  void _internal_set_level_up(bool value);
  public:

  // bool success = 5;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.AddExpRsp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  int32_t new_level_;
  int32_t new_exp_;
  bool level_up_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.EnterRoomReq) */ {
 public:
  inline EnterRoomReq() : EnterRoomReq(nullptr) {}
  ~EnterRoomReq() override;
  explicit constexpr EnterRoomReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterRoomReq(const EnterRoomReq& from);
  EnterRoomReq(EnterRoomReq&& from) noexcept
    : EnterRoomReq() {
    *this = ::std::move(from);
  }

  inline EnterRoomReq& operator=(const EnterRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomReq& operator=(EnterRoomReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterRoomReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterRoomReq* internal_default_instance() {
    return reinterpret_cast<const EnterRoomReq*>(
               &_EnterRoomReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EnterRoomReq& a, EnterRoomReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterRoomReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterRoomReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterRoomReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnterRoomReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.EnterRoomReq";
  }
  protected:
  explicit EnterRoomReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kRoomidFieldNumber = 2,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 roomid = 2;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.EnterRoomReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  int32_t roomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.EnterRoomAck) */ {
 public:
  inline EnterRoomAck() : EnterRoomAck(nullptr) {}
  ~EnterRoomAck() override;
  explicit constexpr EnterRoomAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterRoomAck(const EnterRoomAck& from);
  EnterRoomAck(EnterRoomAck&& from) noexcept
    : EnterRoomAck() {
    *this = ::std::move(from);
  }

  inline EnterRoomAck& operator=(const EnterRoomAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomAck& operator=(EnterRoomAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterRoomAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterRoomAck* internal_default_instance() {
    return reinterpret_cast<const EnterRoomAck*>(
               &_EnterRoomAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(EnterRoomAck& a, EnterRoomAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterRoomAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterRoomAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterRoomAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EnterRoomAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.EnterRoomAck";
  }
  protected:
  explicit EnterRoomAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 3,
    kRoomidFieldNumber = 1,
    kOkFieldNumber = 2,
  };
  // string reason = 3;
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // bool ok = 2;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.EnterRoomAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  int32_t roomid_;
  bool ok_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class ReadyReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ReadyReq) */ {
 public:
  inline ReadyReq() : ReadyReq(nullptr) {}
  ~ReadyReq() override;
  explicit constexpr ReadyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadyReq(const ReadyReq& from);
  ReadyReq(ReadyReq&& from) noexcept
    : ReadyReq() {
    *this = ::std::move(from);
  }

  inline ReadyReq& operator=(const ReadyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadyReq& operator=(ReadyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadyReq* internal_default_instance() {
    return reinterpret_cast<const ReadyReq*>(
               &_ReadyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ReadyReq& a, ReadyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadyReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadyReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadyReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ReadyReq";
  }
  protected:
  explicit ReadyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kRoomidFieldNumber = 2,
    kReadyFieldNumber = 3,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 roomid = 2;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // bool ready = 3;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ReadyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  int32_t roomid_;
  bool ready_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class ReadyAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.ReadyAck) */ {
 public:
  inline ReadyAck() : ReadyAck(nullptr) {}
  ~ReadyAck() override;
  explicit constexpr ReadyAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadyAck(const ReadyAck& from);
  ReadyAck(ReadyAck&& from) noexcept
    : ReadyAck() {
    *this = ::std::move(from);
  }

  inline ReadyAck& operator=(const ReadyAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadyAck& operator=(ReadyAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadyAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadyAck* internal_default_instance() {
    return reinterpret_cast<const ReadyAck*>(
               &_ReadyAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReadyAck& a, ReadyAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadyAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadyAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadyAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadyAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadyAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadyAck& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadyAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ReadyAck";
  }
  protected:
  explicit ReadyAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kRoomidFieldNumber = 2,
    kReadyFieldNumber = 3,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 roomid = 2;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // bool ready = 3;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ReadyAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  int32_t roomid_;
  bool ready_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class BattleAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.BattleAction) */ {
 public:
  inline BattleAction() : BattleAction(nullptr) {}
  ~BattleAction() override;
  explicit constexpr BattleAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BattleAction(const BattleAction& from);
  BattleAction(BattleAction&& from) noexcept
    : BattleAction() {
    *this = ::std::move(from);
  }

  inline BattleAction& operator=(const BattleAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleAction& operator=(BattleAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleAction* internal_default_instance() {
    return reinterpret_cast<const BattleAction*>(
               &_BattleAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BattleAction& a, BattleAction& b) {
    a.Swap(&b);
  }
  inline void Swap(BattleAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BattleAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BattleAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BattleAction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BattleAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.BattleAction";
  }
  protected:
  explicit BattleAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kRoomidFieldNumber = 2,
    kSkillidFieldNumber = 3,
    kTargetFieldNumber = 4,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 roomid = 2;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 skillid = 3;
  void clear_skillid();
  int32_t skillid() const;
  void set_skillid(int32_t value);
  private:
  int32_t _internal_skillid() const;
  void _internal_set_skillid(int32_t value);
  public:

  // int32 target = 4;
  void clear_target();
  int32_t target() const;
  void set_target(int32_t value);
  private:
  int32_t _internal_target() const;
  void _internal_set_target(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.BattleAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  int32_t roomid_;
  int32_t skillid_;
  int32_t target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class BattleState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.BattleState) */ {
 public:
  inline BattleState() : BattleState(nullptr) {}
  ~BattleState() override;
  explicit constexpr BattleState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BattleState(const BattleState& from);
  BattleState(BattleState&& from) noexcept
    : BattleState() {
    *this = ::std::move(from);
  }

  inline BattleState& operator=(const BattleState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleState& operator=(BattleState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleState* internal_default_instance() {
    return reinterpret_cast<const BattleState*>(
               &_BattleState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BattleState& a, BattleState& b) {
    a.Swap(&b);
  }
  inline void Swap(BattleState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BattleState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BattleState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BattleState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BattleState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.BattleState";
  }
  protected:
  explicit BattleState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kHpFieldNumber = 2,
    kMpFieldNumber = 3,
  };
  // int32 uid = 1;
  void clear_uid();
  int32_t uid() const;
  void set_uid(int32_t value);
  private:
  int32_t _internal_uid() const;
  void _internal_set_uid(int32_t value);
  public:

  // int32 hp = 2;
  void clear_hp();
  int32_t hp() const;
  void set_hp(int32_t value);
  private:
  int32_t _internal_hp() const;
  void _internal_set_hp(int32_t value);
  public:

  // int32 mp = 3;
  void clear_mp();
  int32_t mp() const;
  void set_mp(int32_t value);
  private:
  int32_t _internal_mp() const;
  void _internal_set_mp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.BattleState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t uid_;
  int32_t hp_;
  int32_t mp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class BattleSync final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.BattleSync) */ {
 public:
  inline BattleSync() : BattleSync(nullptr) {}
  ~BattleSync() override;
  explicit constexpr BattleSync(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BattleSync(const BattleSync& from);
  BattleSync(BattleSync&& from) noexcept
    : BattleSync() {
    *this = ::std::move(from);
  }

  inline BattleSync& operator=(const BattleSync& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleSync& operator=(BattleSync&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleSync& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleSync* internal_default_instance() {
    return reinterpret_cast<const BattleSync*>(
               &_BattleSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BattleSync& a, BattleSync& b) {
    a.Swap(&b);
  }
  inline void Swap(BattleSync* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleSync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleSync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BattleSync>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BattleSync& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BattleSync& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BattleSync* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.BattleSync";
  }
  protected:
  explicit BattleSync(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // repeated .msg.BattleState states = 1;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  ::msg::BattleState* mutable_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::BattleState >*
      mutable_states();
  private:
  const ::msg::BattleState& _internal_states(int index) const;
  ::msg::BattleState* _internal_add_states();
  public:
  const ::msg::BattleState& states(int index) const;
  ::msg::BattleState* add_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::BattleState >&
      states() const;

  // int64 timestamp = 2;
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.BattleSync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::BattleState > states_;
  int64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class BattleStart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.BattleStart) */ {
 public:
  inline BattleStart() : BattleStart(nullptr) {}
  ~BattleStart() override;
  explicit constexpr BattleStart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BattleStart(const BattleStart& from);
  BattleStart(BattleStart&& from) noexcept
    : BattleStart() {
    *this = ::std::move(from);
  }

  inline BattleStart& operator=(const BattleStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleStart& operator=(BattleStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleStart* internal_default_instance() {
    return reinterpret_cast<const BattleStart*>(
               &_BattleStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BattleStart& a, BattleStart& b) {
    a.Swap(&b);
  }
  inline void Swap(BattleStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BattleStart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BattleStart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BattleStart& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BattleStart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.BattleStart";
  }
  protected:
  explicit BattleStart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kRoomidFieldNumber = 1,
  };
  // repeated int32 players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  private:
  int32_t _internal_players(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_players() const;
  void _internal_add_players(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_players();
  public:
  int32_t players(int index) const;
  void set_players(int index, int32_t value);
  void add_players(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      players() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_players();

  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.BattleStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > players_;
  mutable std::atomic<int> _players_cached_byte_size_;
  int32_t roomid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class BattleEnd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:msg.BattleEnd) */ {
 public:
  inline BattleEnd() : BattleEnd(nullptr) {}
  ~BattleEnd() override;
  explicit constexpr BattleEnd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BattleEnd(const BattleEnd& from);
  BattleEnd(BattleEnd&& from) noexcept
    : BattleEnd() {
    *this = ::std::move(from);
  }

  inline BattleEnd& operator=(const BattleEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleEnd& operator=(BattleEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleEnd* internal_default_instance() {
    return reinterpret_cast<const BattleEnd*>(
               &_BattleEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BattleEnd& a, BattleEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(BattleEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleEnd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BattleEnd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BattleEnd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BattleEnd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BattleEnd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.BattleEnd";
  }
  protected:
  explicit BattleEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomidFieldNumber = 1,
    kWinnerFieldNumber = 2,
  };
  // int32 roomid = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 winner = 2;
  void clear_winner();
  int32_t winner() const;
  void set_winner(int32_t value);
  private:
  int32_t _internal_winner() const;
  void _internal_set_winner(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:msg.BattleEnd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t roomid_;
  int32_t winner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChatMsg

// .msg.ChatChannel channel = 1;
inline void ChatMsg::clear_channel() {
  channel_ = 0;
}
inline ::msg::ChatChannel ChatMsg::_internal_channel() const {
  return static_cast< ::msg::ChatChannel >(channel_);
}
inline ::msg::ChatChannel ChatMsg::channel() const {
  // @@protoc_insertion_point(field_get:msg.ChatMsg.channel)
  return _internal_channel();
}
inline void ChatMsg::_internal_set_channel(::msg::ChatChannel value) {
  
  channel_ = value;
}
inline void ChatMsg::set_channel(::msg::ChatChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:msg.ChatMsg.channel)
}

// int32 to = 2;
inline void ChatMsg::clear_to() {
  to_ = 0;
}
inline int32_t ChatMsg::_internal_to() const {
  return to_;
}
inline int32_t ChatMsg::to() const {
  // @@protoc_insertion_point(field_get:msg.ChatMsg.to)
  return _internal_to();
}
inline void ChatMsg::_internal_set_to(int32_t value) {
  
  to_ = value;
}
inline void ChatMsg::set_to(int32_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:msg.ChatMsg.to)
}

// string text = 3;
inline void ChatMsg::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& ChatMsg::text() const {
  // @@protoc_insertion_point(field_get:msg.ChatMsg.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatMsg::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.ChatMsg.text)
}
inline std::string* ChatMsg::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:msg.ChatMsg.text)
  return _s;
}
inline const std::string& ChatMsg::_internal_text() const {
  return text_.Get();
}
inline void ChatMsg::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ChatMsg::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ChatMsg::release_text() {
  // @@protoc_insertion_point(field_release:msg.ChatMsg.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ChatMsg::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.ChatMsg.text)
}

// -------------------------------------------------------------------

// SChatMsg

// .msg.ChatChannel channel = 1;
inline void SChatMsg::clear_channel() {
  channel_ = 0;
}
inline ::msg::ChatChannel SChatMsg::_internal_channel() const {
  return static_cast< ::msg::ChatChannel >(channel_);
}
inline ::msg::ChatChannel SChatMsg::channel() const {
  // @@protoc_insertion_point(field_get:msg.SChatMsg.channel)
  return _internal_channel();
}
inline void SChatMsg::_internal_set_channel(::msg::ChatChannel value) {
  
  channel_ = value;
}
inline void SChatMsg::set_channel(::msg::ChatChannel value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:msg.SChatMsg.channel)
}

// int32 from = 2;
inline void SChatMsg::clear_from() {
  from_ = 0;
}
inline int32_t SChatMsg::_internal_from() const {
  return from_;
}
inline int32_t SChatMsg::from() const {
  // @@protoc_insertion_point(field_get:msg.SChatMsg.from)
  return _internal_from();
}
inline void SChatMsg::_internal_set_from(int32_t value) {
  
  from_ = value;
}
inline void SChatMsg::set_from(int32_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:msg.SChatMsg.from)
}

// string text = 3;
inline void SChatMsg::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& SChatMsg::text() const {
  // @@protoc_insertion_point(field_get:msg.SChatMsg.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SChatMsg::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.SChatMsg.text)
}
inline std::string* SChatMsg::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:msg.SChatMsg.text)
  return _s;
}
inline const std::string& SChatMsg::_internal_text() const {
  return text_.Get();
}
inline void SChatMsg::_internal_set_text(const std::string& value) {
  
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SChatMsg::_internal_mutable_text() {
  
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SChatMsg::release_text() {
  // @@protoc_insertion_point(field_release:msg.SChatMsg.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SChatMsg::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.SChatMsg.text)
}

// -------------------------------------------------------------------

// ViewPlayerDataReq

// int32 uid = 1;
inline void ViewPlayerDataReq::clear_uid() {
  uid_ = 0;
}
inline int32_t ViewPlayerDataReq::_internal_uid() const {
  return uid_;
}
inline int32_t ViewPlayerDataReq::uid() const {
  // @@protoc_insertion_point(field_get:msg.ViewPlayerDataReq.uid)
  return _internal_uid();
}
inline void ViewPlayerDataReq::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void ViewPlayerDataReq::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.ViewPlayerDataReq.uid)
}

// -------------------------------------------------------------------

// PlayerAttr

// int32 uid = 1;
inline void PlayerAttr::clear_uid() {
  uid_ = 0;
}
inline int32_t PlayerAttr::_internal_uid() const {
  return uid_;
}
inline int32_t PlayerAttr::uid() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.uid)
  return _internal_uid();
}
inline void PlayerAttr::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void PlayerAttr::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.uid)
}

// int32 level = 3;
inline void PlayerAttr::clear_level() {
  level_ = 0;
}
inline int32_t PlayerAttr::_internal_level() const {
  return level_;
}
inline int32_t PlayerAttr::level() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.level)
  return _internal_level();
}
inline void PlayerAttr::_internal_set_level(int32_t value) {
  
  level_ = value;
}
inline void PlayerAttr::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.level)
}

// int32 exp = 4;
inline void PlayerAttr::clear_exp() {
  exp_ = 0;
}
inline int32_t PlayerAttr::_internal_exp() const {
  return exp_;
}
inline int32_t PlayerAttr::exp() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.exp)
  return _internal_exp();
}
inline void PlayerAttr::_internal_set_exp(int32_t value) {
  
  exp_ = value;
}
inline void PlayerAttr::set_exp(int32_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.exp)
}

// int32 hp = 5;
inline void PlayerAttr::clear_hp() {
  hp_ = 0;
}
inline int32_t PlayerAttr::_internal_hp() const {
  return hp_;
}
inline int32_t PlayerAttr::hp() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.hp)
  return _internal_hp();
}
inline void PlayerAttr::_internal_set_hp(int32_t value) {
  
  hp_ = value;
}
inline void PlayerAttr::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.hp)
}

// int32 mp = 6;
inline void PlayerAttr::clear_mp() {
  mp_ = 0;
}
inline int32_t PlayerAttr::_internal_mp() const {
  return mp_;
}
inline int32_t PlayerAttr::mp() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.mp)
  return _internal_mp();
}
inline void PlayerAttr::_internal_set_mp(int32_t value) {
  
  mp_ = value;
}
inline void PlayerAttr::set_mp(int32_t value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.mp)
}

// int32 coin = 7;
inline void PlayerAttr::clear_coin() {
  coin_ = 0;
}
inline int32_t PlayerAttr::_internal_coin() const {
  return coin_;
}
inline int32_t PlayerAttr::coin() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.coin)
  return _internal_coin();
}
inline void PlayerAttr::_internal_set_coin(int32_t value) {
  
  coin_ = value;
}
inline void PlayerAttr::set_coin(int32_t value) {
  _internal_set_coin(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.coin)
}

// float x = 8;
inline void PlayerAttr::clear_x() {
  x_ = 0;
}
inline float PlayerAttr::_internal_x() const {
  return x_;
}
inline float PlayerAttr::x() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.x)
  return _internal_x();
}
inline void PlayerAttr::_internal_set_x(float value) {
  
  x_ = value;
}
inline void PlayerAttr::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.x)
}

// float y = 9;
inline void PlayerAttr::clear_y() {
  y_ = 0;
}
inline float PlayerAttr::_internal_y() const {
  return y_;
}
inline float PlayerAttr::y() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.y)
  return _internal_y();
}
inline void PlayerAttr::_internal_set_y(float value) {
  
  y_ = value;
}
inline void PlayerAttr::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.y)
}

// float z = 10;
inline void PlayerAttr::clear_z() {
  z_ = 0;
}
inline float PlayerAttr::_internal_z() const {
  return z_;
}
inline float PlayerAttr::z() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAttr.z)
  return _internal_z();
}
inline void PlayerAttr::_internal_set_z(float value) {
  
  z_ = value;
}
inline void PlayerAttr::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAttr.z)
}

// -------------------------------------------------------------------

// RegisterReq

// string name = 1;
inline void RegisterReq::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& RegisterReq::name() const {
  // @@protoc_insertion_point(field_get:msg.RegisterReq.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.RegisterReq.name)
}
inline std::string* RegisterReq::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:msg.RegisterReq.name)
  return _s;
}
inline const std::string& RegisterReq::_internal_name() const {
  return name_.Get();
}
inline void RegisterReq::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterReq::release_name() {
  // @@protoc_insertion_point(field_release:msg.RegisterReq.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.RegisterReq.name)
}

// string passwd = 2;
inline void RegisterReq::clear_passwd() {
  passwd_.ClearToEmpty();
}
inline const std::string& RegisterReq::passwd() const {
  // @@protoc_insertion_point(field_get:msg.RegisterReq.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterReq::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.RegisterReq.passwd)
}
inline std::string* RegisterReq::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:msg.RegisterReq.passwd)
  return _s;
}
inline const std::string& RegisterReq::_internal_passwd() const {
  return passwd_.Get();
}
inline void RegisterReq::_internal_set_passwd(const std::string& value) {
  
  passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterReq::_internal_mutable_passwd() {
  
  return passwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterReq::release_passwd() {
  // @@protoc_insertion_point(field_release:msg.RegisterReq.passwd)
  return passwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterReq::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  passwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (passwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    passwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.RegisterReq.passwd)
}

// -------------------------------------------------------------------

// RegisterResp

// bool ok = 1;
inline void RegisterResp::clear_ok() {
  ok_ = false;
}
inline bool RegisterResp::_internal_ok() const {
  return ok_;
}
inline bool RegisterResp::ok() const {
  // @@protoc_insertion_point(field_get:msg.RegisterResp.ok)
  return _internal_ok();
}
inline void RegisterResp::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void RegisterResp::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:msg.RegisterResp.ok)
}

// string reason = 2;
inline void RegisterResp::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& RegisterResp::reason() const {
  // @@protoc_insertion_point(field_get:msg.RegisterResp.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResp::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.RegisterResp.reason)
}
inline std::string* RegisterResp::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:msg.RegisterResp.reason)
  return _s;
}
inline const std::string& RegisterResp::_internal_reason() const {
  return reason_.Get();
}
inline void RegisterResp::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterResp::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterResp::release_reason() {
  // @@protoc_insertion_point(field_release:msg.RegisterResp.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterResp::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.RegisterResp.reason)
}

// int32 uid = 3;
inline void RegisterResp::clear_uid() {
  uid_ = 0;
}
inline int32_t RegisterResp::_internal_uid() const {
  return uid_;
}
inline int32_t RegisterResp::uid() const {
  // @@protoc_insertion_point(field_get:msg.RegisterResp.uid)
  return _internal_uid();
}
inline void RegisterResp::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void RegisterResp::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.RegisterResp.uid)
}

// -------------------------------------------------------------------

// LoginReq

// int32 uid = 1;
inline void LoginReq::clear_uid() {
  uid_ = 0;
}
inline int32_t LoginReq::_internal_uid() const {
  return uid_;
}
inline int32_t LoginReq::uid() const {
  // @@protoc_insertion_point(field_get:msg.LoginReq.uid)
  return _internal_uid();
}
inline void LoginReq::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void LoginReq::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.LoginReq.uid)
}

// string passwd = 2;
inline void LoginReq::clear_passwd() {
  passwd_.ClearToEmpty();
}
inline const std::string& LoginReq::passwd() const {
  // @@protoc_insertion_point(field_get:msg.LoginReq.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginReq::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.LoginReq.passwd)
}
inline std::string* LoginReq::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:msg.LoginReq.passwd)
  return _s;
}
inline const std::string& LoginReq::_internal_passwd() const {
  return passwd_.Get();
}
inline void LoginReq::_internal_set_passwd(const std::string& value) {
  
  passwd_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginReq::_internal_mutable_passwd() {
  
  return passwd_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginReq::release_passwd() {
  // @@protoc_insertion_point(field_release:msg.LoginReq.passwd)
  return passwd_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginReq::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  passwd_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), passwd,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (passwd_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    passwd_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.LoginReq.passwd)
}

// -------------------------------------------------------------------

// LoginResp

// bool ok = 1;
inline void LoginResp::clear_ok() {
  ok_ = false;
}
inline bool LoginResp::_internal_ok() const {
  return ok_;
}
inline bool LoginResp::ok() const {
  // @@protoc_insertion_point(field_get:msg.LoginResp.ok)
  return _internal_ok();
}
inline void LoginResp::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void LoginResp::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:msg.LoginResp.ok)
}

// string reason = 2;
inline void LoginResp::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& LoginResp::reason() const {
  // @@protoc_insertion_point(field_get:msg.LoginResp.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResp::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.LoginResp.reason)
}
inline std::string* LoginResp::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:msg.LoginResp.reason)
  return _s;
}
inline const std::string& LoginResp::_internal_reason() const {
  return reason_.Get();
}
inline void LoginResp::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LoginResp::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LoginResp::release_reason() {
  // @@protoc_insertion_point(field_release:msg.LoginResp.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LoginResp::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.LoginResp.reason)
}

// -------------------------------------------------------------------

// PositionUpdateReq

// float x = 1;
inline void PositionUpdateReq::clear_x() {
  x_ = 0;
}
inline float PositionUpdateReq::_internal_x() const {
  return x_;
}
inline float PositionUpdateReq::x() const {
  // @@protoc_insertion_point(field_get:msg.PositionUpdateReq.x)
  return _internal_x();
}
inline void PositionUpdateReq::_internal_set_x(float value) {
  
  x_ = value;
}
inline void PositionUpdateReq::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:msg.PositionUpdateReq.x)
}

// float y = 2;
inline void PositionUpdateReq::clear_y() {
  y_ = 0;
}
inline float PositionUpdateReq::_internal_y() const {
  return y_;
}
inline float PositionUpdateReq::y() const {
  // @@protoc_insertion_point(field_get:msg.PositionUpdateReq.y)
  return _internal_y();
}
inline void PositionUpdateReq::_internal_set_y(float value) {
  
  y_ = value;
}
inline void PositionUpdateReq::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:msg.PositionUpdateReq.y)
}

// float z = 3;
inline void PositionUpdateReq::clear_z() {
  z_ = 0;
}
inline float PositionUpdateReq::_internal_z() const {
  return z_;
}
inline float PositionUpdateReq::z() const {
  // @@protoc_insertion_point(field_get:msg.PositionUpdateReq.z)
  return _internal_z();
}
inline void PositionUpdateReq::_internal_set_z(float value) {
  
  z_ = value;
}
inline void PositionUpdateReq::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:msg.PositionUpdateReq.z)
}

// -------------------------------------------------------------------

// AddExpReq

// int32 uid = 1;
inline void AddExpReq::clear_uid() {
  uid_ = 0;
}
inline int32_t AddExpReq::_internal_uid() const {
  return uid_;
}
inline int32_t AddExpReq::uid() const {
  // @@protoc_insertion_point(field_get:msg.AddExpReq.uid)
  return _internal_uid();
}
inline void AddExpReq::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void AddExpReq::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.AddExpReq.uid)
}

// int32 exp_add = 2;
inline void AddExpReq::clear_exp_add() {
  exp_add_ = 0;
}
inline int32_t AddExpReq::_internal_exp_add() const {
  return exp_add_;
}
inline int32_t AddExpReq::exp_add() const {
  // @@protoc_insertion_point(field_get:msg.AddExpReq.exp_add)
  return _internal_exp_add();
}
inline void AddExpReq::_internal_set_exp_add(int32_t value) {
  
  exp_add_ = value;
}
inline void AddExpReq::set_exp_add(int32_t value) {
  _internal_set_exp_add(value);
  // @@protoc_insertion_point(field_set:msg.AddExpReq.exp_add)
}

// -------------------------------------------------------------------

// AddExpRsp

// int32 uid = 1;
inline void AddExpRsp::clear_uid() {
  uid_ = 0;
}
inline int32_t AddExpRsp::_internal_uid() const {
  return uid_;
}
inline int32_t AddExpRsp::uid() const {
  // @@protoc_insertion_point(field_get:msg.AddExpRsp.uid)
  return _internal_uid();
}
inline void AddExpRsp::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void AddExpRsp::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.AddExpRsp.uid)
}

// int32 new_level = 2;
inline void AddExpRsp::clear_new_level() {
  new_level_ = 0;
}
inline int32_t AddExpRsp::_internal_new_level() const {
  return new_level_;
}
inline int32_t AddExpRsp::new_level() const {
  // @@protoc_insertion_point(field_get:msg.AddExpRsp.new_level)
  return _internal_new_level();
}
inline void AddExpRsp::_internal_set_new_level(int32_t value) {
  
  new_level_ = value;
}
inline void AddExpRsp::set_new_level(int32_t value) {
  _internal_set_new_level(value);
  // @@protoc_insertion_point(field_set:msg.AddExpRsp.new_level)
}

// int32 new_exp = 3;
inline void AddExpRsp::clear_new_exp() {
  new_exp_ = 0;
}
inline int32_t AddExpRsp::_internal_new_exp() const {
  return new_exp_;
}
inline int32_t AddExpRsp::new_exp() const {
  // @@protoc_insertion_point(field_get:msg.AddExpRsp.new_exp)
  return _internal_new_exp();
}
inline void AddExpRsp::_internal_set_new_exp(int32_t value) {
  
  new_exp_ = value;
}
inline void AddExpRsp::set_new_exp(int32_t value) {
  _internal_set_new_exp(value);
  // @@protoc_insertion_point(field_set:msg.AddExpRsp.new_exp)
}

// bool level_up = 4;
inline void AddExpRsp::clear_level_up() {
  level_up_ = false;
}
inline bool AddExpRsp::_internal_level_up() const {
  return level_up_;
}
inline bool AddExpRsp::level_up() const {
  // @@protoc_insertion_point(field_get:msg.AddExpRsp.level_up)
  return _internal_level_up();
}
inline void AddExpRsp::_internal_set_level_up(bool value) {
  
  level_up_ = value;
}
inline void AddExpRsp::set_level_up(bool value) {
  _internal_set_level_up(value);
  // @@protoc_insertion_point(field_set:msg.AddExpRsp.level_up)
}

// bool success = 5;
inline void AddExpRsp::clear_success() {
  success_ = false;
}
inline bool AddExpRsp::_internal_success() const {
  return success_;
}
inline bool AddExpRsp::success() const {
  // @@protoc_insertion_point(field_get:msg.AddExpRsp.success)
  return _internal_success();
}
inline void AddExpRsp::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AddExpRsp::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:msg.AddExpRsp.success)
}

// -------------------------------------------------------------------

// EnterRoomReq

// int32 uid = 1;
inline void EnterRoomReq::clear_uid() {
  uid_ = 0;
}
inline int32_t EnterRoomReq::_internal_uid() const {
  return uid_;
}
inline int32_t EnterRoomReq::uid() const {
  // @@protoc_insertion_point(field_get:msg.EnterRoomReq.uid)
  return _internal_uid();
}
inline void EnterRoomReq::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void EnterRoomReq::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.EnterRoomReq.uid)
}

// int32 roomid = 2;
inline void EnterRoomReq::clear_roomid() {
  roomid_ = 0;
}
inline int32_t EnterRoomReq::_internal_roomid() const {
  return roomid_;
}
inline int32_t EnterRoomReq::roomid() const {
  // @@protoc_insertion_point(field_get:msg.EnterRoomReq.roomid)
  return _internal_roomid();
}
inline void EnterRoomReq::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void EnterRoomReq::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:msg.EnterRoomReq.roomid)
}

// -------------------------------------------------------------------

// EnterRoomAck

// int32 roomid = 1;
inline void EnterRoomAck::clear_roomid() {
  roomid_ = 0;
}
inline int32_t EnterRoomAck::_internal_roomid() const {
  return roomid_;
}
inline int32_t EnterRoomAck::roomid() const {
  // @@protoc_insertion_point(field_get:msg.EnterRoomAck.roomid)
  return _internal_roomid();
}
inline void EnterRoomAck::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void EnterRoomAck::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:msg.EnterRoomAck.roomid)
}

// bool ok = 2;
inline void EnterRoomAck::clear_ok() {
  ok_ = false;
}
inline bool EnterRoomAck::_internal_ok() const {
  return ok_;
}
inline bool EnterRoomAck::ok() const {
  // @@protoc_insertion_point(field_get:msg.EnterRoomAck.ok)
  return _internal_ok();
}
inline void EnterRoomAck::_internal_set_ok(bool value) {
  
  ok_ = value;
}
inline void EnterRoomAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:msg.EnterRoomAck.ok)
}

// string reason = 3;
inline void EnterRoomAck::clear_reason() {
  reason_.ClearToEmpty();
}
inline const std::string& EnterRoomAck::reason() const {
  // @@protoc_insertion_point(field_get:msg.EnterRoomAck.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnterRoomAck::set_reason(ArgT0&& arg0, ArgT... args) {
 
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:msg.EnterRoomAck.reason)
}
inline std::string* EnterRoomAck::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:msg.EnterRoomAck.reason)
  return _s;
}
inline const std::string& EnterRoomAck::_internal_reason() const {
  return reason_.Get();
}
inline void EnterRoomAck::_internal_set_reason(const std::string& value) {
  
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EnterRoomAck::_internal_mutable_reason() {
  
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EnterRoomAck::release_reason() {
  // @@protoc_insertion_point(field_release:msg.EnterRoomAck.reason)
  return reason_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EnterRoomAck::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    
  } else {
    
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:msg.EnterRoomAck.reason)
}

// -------------------------------------------------------------------

// ReadyReq

// int32 uid = 1;
inline void ReadyReq::clear_uid() {
  uid_ = 0;
}
inline int32_t ReadyReq::_internal_uid() const {
  return uid_;
}
inline int32_t ReadyReq::uid() const {
  // @@protoc_insertion_point(field_get:msg.ReadyReq.uid)
  return _internal_uid();
}
inline void ReadyReq::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void ReadyReq::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.ReadyReq.uid)
}

// int32 roomid = 2;
inline void ReadyReq::clear_roomid() {
  roomid_ = 0;
}
inline int32_t ReadyReq::_internal_roomid() const {
  return roomid_;
}
inline int32_t ReadyReq::roomid() const {
  // @@protoc_insertion_point(field_get:msg.ReadyReq.roomid)
  return _internal_roomid();
}
inline void ReadyReq::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void ReadyReq::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:msg.ReadyReq.roomid)
}

// bool ready = 3;
inline void ReadyReq::clear_ready() {
  ready_ = false;
}
inline bool ReadyReq::_internal_ready() const {
  return ready_;
}
inline bool ReadyReq::ready() const {
  // @@protoc_insertion_point(field_get:msg.ReadyReq.ready)
  return _internal_ready();
}
inline void ReadyReq::_internal_set_ready(bool value) {
  
  ready_ = value;
}
inline void ReadyReq::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:msg.ReadyReq.ready)
}

// -------------------------------------------------------------------

// ReadyAck

// int32 uid = 1;
inline void ReadyAck::clear_uid() {
  uid_ = 0;
}
inline int32_t ReadyAck::_internal_uid() const {
  return uid_;
}
inline int32_t ReadyAck::uid() const {
  // @@protoc_insertion_point(field_get:msg.ReadyAck.uid)
  return _internal_uid();
}
inline void ReadyAck::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void ReadyAck::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.ReadyAck.uid)
}

// int32 roomid = 2;
inline void ReadyAck::clear_roomid() {
  roomid_ = 0;
}
inline int32_t ReadyAck::_internal_roomid() const {
  return roomid_;
}
inline int32_t ReadyAck::roomid() const {
  // @@protoc_insertion_point(field_get:msg.ReadyAck.roomid)
  return _internal_roomid();
}
inline void ReadyAck::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void ReadyAck::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:msg.ReadyAck.roomid)
}

// bool ready = 3;
inline void ReadyAck::clear_ready() {
  ready_ = false;
}
inline bool ReadyAck::_internal_ready() const {
  return ready_;
}
inline bool ReadyAck::ready() const {
  // @@protoc_insertion_point(field_get:msg.ReadyAck.ready)
  return _internal_ready();
}
inline void ReadyAck::_internal_set_ready(bool value) {
  
  ready_ = value;
}
inline void ReadyAck::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:msg.ReadyAck.ready)
}

// -------------------------------------------------------------------

// BattleAction

// int32 uid = 1;
inline void BattleAction::clear_uid() {
  uid_ = 0;
}
inline int32_t BattleAction::_internal_uid() const {
  return uid_;
}
inline int32_t BattleAction::uid() const {
  // @@protoc_insertion_point(field_get:msg.BattleAction.uid)
  return _internal_uid();
}
inline void BattleAction::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void BattleAction::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.BattleAction.uid)
}

// int32 roomid = 2;
inline void BattleAction::clear_roomid() {
  roomid_ = 0;
}
inline int32_t BattleAction::_internal_roomid() const {
  return roomid_;
}
inline int32_t BattleAction::roomid() const {
  // @@protoc_insertion_point(field_get:msg.BattleAction.roomid)
  return _internal_roomid();
}
inline void BattleAction::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void BattleAction::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:msg.BattleAction.roomid)
}

// int32 skillid = 3;
inline void BattleAction::clear_skillid() {
  skillid_ = 0;
}
inline int32_t BattleAction::_internal_skillid() const {
  return skillid_;
}
inline int32_t BattleAction::skillid() const {
  // @@protoc_insertion_point(field_get:msg.BattleAction.skillid)
  return _internal_skillid();
}
inline void BattleAction::_internal_set_skillid(int32_t value) {
  
  skillid_ = value;
}
inline void BattleAction::set_skillid(int32_t value) {
  _internal_set_skillid(value);
  // @@protoc_insertion_point(field_set:msg.BattleAction.skillid)
}

// int32 target = 4;
inline void BattleAction::clear_target() {
  target_ = 0;
}
inline int32_t BattleAction::_internal_target() const {
  return target_;
}
inline int32_t BattleAction::target() const {
  // @@protoc_insertion_point(field_get:msg.BattleAction.target)
  return _internal_target();
}
inline void BattleAction::_internal_set_target(int32_t value) {
  
  target_ = value;
}
inline void BattleAction::set_target(int32_t value) {
  _internal_set_target(value);
  // @@protoc_insertion_point(field_set:msg.BattleAction.target)
}

// -------------------------------------------------------------------

// BattleState

// int32 uid = 1;
inline void BattleState::clear_uid() {
  uid_ = 0;
}
inline int32_t BattleState::_internal_uid() const {
  return uid_;
}
inline int32_t BattleState::uid() const {
  // @@protoc_insertion_point(field_get:msg.BattleState.uid)
  return _internal_uid();
}
inline void BattleState::_internal_set_uid(int32_t value) {
  
  uid_ = value;
}
inline void BattleState::set_uid(int32_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:msg.BattleState.uid)
}

// int32 hp = 2;
inline void BattleState::clear_hp() {
  hp_ = 0;
}
inline int32_t BattleState::_internal_hp() const {
  return hp_;
}
inline int32_t BattleState::hp() const {
  // @@protoc_insertion_point(field_get:msg.BattleState.hp)
  return _internal_hp();
}
inline void BattleState::_internal_set_hp(int32_t value) {
  
  hp_ = value;
}
inline void BattleState::set_hp(int32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:msg.BattleState.hp)
}

// int32 mp = 3;
inline void BattleState::clear_mp() {
  mp_ = 0;
}
inline int32_t BattleState::_internal_mp() const {
  return mp_;
}
inline int32_t BattleState::mp() const {
  // @@protoc_insertion_point(field_get:msg.BattleState.mp)
  return _internal_mp();
}
inline void BattleState::_internal_set_mp(int32_t value) {
  
  mp_ = value;
}
inline void BattleState::set_mp(int32_t value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:msg.BattleState.mp)
}

// -------------------------------------------------------------------

// BattleSync

// repeated .msg.BattleState states = 1;
inline int BattleSync::_internal_states_size() const {
  return states_.size();
}
inline int BattleSync::states_size() const {
  return _internal_states_size();
}
inline void BattleSync::clear_states() {
  states_.Clear();
}
inline ::msg::BattleState* BattleSync::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:msg.BattleSync.states)
  return states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::BattleState >*
BattleSync::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:msg.BattleSync.states)
  return &states_;
}
inline const ::msg::BattleState& BattleSync::_internal_states(int index) const {
  return states_.Get(index);
}
inline const ::msg::BattleState& BattleSync::states(int index) const {
  // @@protoc_insertion_point(field_get:msg.BattleSync.states)
  return _internal_states(index);
}
inline ::msg::BattleState* BattleSync::_internal_add_states() {
  return states_.Add();
}
inline ::msg::BattleState* BattleSync::add_states() {
  ::msg::BattleState* _add = _internal_add_states();
  // @@protoc_insertion_point(field_add:msg.BattleSync.states)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::BattleState >&
BattleSync::states() const {
  // @@protoc_insertion_point(field_list:msg.BattleSync.states)
  return states_;
}

// int64 timestamp = 2;
inline void BattleSync::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t BattleSync::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t BattleSync::timestamp() const {
  // @@protoc_insertion_point(field_get:msg.BattleSync.timestamp)
  return _internal_timestamp();
}
inline void BattleSync::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void BattleSync::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:msg.BattleSync.timestamp)
}

// -------------------------------------------------------------------

// BattleStart

// int32 roomid = 1;
inline void BattleStart::clear_roomid() {
  roomid_ = 0;
}
inline int32_t BattleStart::_internal_roomid() const {
  return roomid_;
}
inline int32_t BattleStart::roomid() const {
  // @@protoc_insertion_point(field_get:msg.BattleStart.roomid)
  return _internal_roomid();
}
inline void BattleStart::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void BattleStart::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:msg.BattleStart.roomid)
}

// repeated int32 players = 2;
inline int BattleStart::_internal_players_size() const {
  return players_.size();
}
inline int BattleStart::players_size() const {
  return _internal_players_size();
}
inline void BattleStart::clear_players() {
  players_.Clear();
}
inline int32_t BattleStart::_internal_players(int index) const {
  return players_.Get(index);
}
inline int32_t BattleStart::players(int index) const {
  // @@protoc_insertion_point(field_get:msg.BattleStart.players)
  return _internal_players(index);
}
inline void BattleStart::set_players(int index, int32_t value) {
  players_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.BattleStart.players)
}
inline void BattleStart::_internal_add_players(int32_t value) {
  players_.Add(value);
}
inline void BattleStart::add_players(int32_t value) {
  _internal_add_players(value);
  // @@protoc_insertion_point(field_add:msg.BattleStart.players)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
BattleStart::_internal_players() const {
  return players_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
BattleStart::players() const {
  // @@protoc_insertion_point(field_list:msg.BattleStart.players)
  return _internal_players();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
BattleStart::_internal_mutable_players() {
  return &players_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
BattleStart::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:msg.BattleStart.players)
  return _internal_mutable_players();
}

// -------------------------------------------------------------------

// BattleEnd

// int32 roomid = 1;
inline void BattleEnd::clear_roomid() {
  roomid_ = 0;
}
inline int32_t BattleEnd::_internal_roomid() const {
  return roomid_;
}
inline int32_t BattleEnd::roomid() const {
  // @@protoc_insertion_point(field_get:msg.BattleEnd.roomid)
  return _internal_roomid();
}
inline void BattleEnd::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void BattleEnd::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:msg.BattleEnd.roomid)
}

// int32 winner = 2;
inline void BattleEnd::clear_winner() {
  winner_ = 0;
}
inline int32_t BattleEnd::_internal_winner() const {
  return winner_;
}
inline int32_t BattleEnd::winner() const {
  // @@protoc_insertion_point(field_get:msg.BattleEnd.winner)
  return _internal_winner();
}
inline void BattleEnd::_internal_set_winner(int32_t value) {
  
  winner_ = value;
}
inline void BattleEnd::set_winner(int32_t value) {
  _internal_set_winner(value);
  // @@protoc_insertion_point(field_set:msg.BattleEnd.winner)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::msg::ChatChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::msg::ChatChannel>() {
  return ::msg::ChatChannel_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
